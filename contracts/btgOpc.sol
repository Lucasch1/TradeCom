// SPDX-License-Identifier: MIT
pragma solidity^0.8.1;


import "./price.sol";
import "../node_modules/@chainlink/contracts/src/v0.8/KeeperCompatible.sol";


interface btgDOL {
    function balanceOf(address _address) external view returns(uint256);
    function transferFrom(address _from, address _to, uint _amout) external returns(bool);
}

contract OptionsList {
    address[] public deployedOptions;

    function createOption(address _opcAddr) public {
        deployedOptions.push(_opcAddr);
    }

    function getDeployedCampaigns() public view returns (address [] memory) {
        return deployedOptions;
    }
}

contract btgOpc is KeeperCompatibleInterface {

    //address private btgdolAddr = 0x41b4eb8323e97C814f4A0aee07e2C8f226291e81;  0x45e0C7F0790f501a92c52bbC59bE6C8ae85bf722
    PriceConsumerV3 public priceEth;
    OptionsList public optList;
    
    uint ethPrice;
    uint contador = 0;
    address addr = 0x0172ae13E3583BF565957095D27caede3Abb172e;
    buyRequest [] public buyersList;
    opcDol public opc;
    mapping(address => bool) canBuy;
    
    //uint256 lastTimeStamp;
    //uint256 interval;
    struct buyRequest {
        address buyer;
        uint value;
    }

    struct opcDol {
            uint strike; // eth em dolar
            uint dataVencimento;
            uint valorCobertura;// numero de eths
            uint emissionPrice;// acho que nao precisa
            uint actualPrice; //acho q nao precisa
            string description;
            bool valid;
            address emissor;
            address buyer;
    }
    

    constructor (uint _strike, uint _date, uint _prizePrice, string memory _description, uint _value, address _chainlinkPriceAddr, address _optionslistAddr) payable {
        
        require(btgDOL(addr).balanceOf(msg.sender) >= _value, "You should have on wallet at least the same ammout of eth on wallet as you want to cover on your option");
        require(msg.value == _value, "You need to lock your ethers in the period the option is being valid");
        
        optList = OptionsList(_optionslistAddr);
        priceEth = PriceConsumerV3(_chainlinkPriceAddr);
        ethPrice = uint(priceEth.getLatestPrice());

        opc = opcDol ({
            strike: _strike,
            dataVencimento: _date,
            valorCobertura: _value,
            emissionPrice: _prizePrice,
            actualPrice: _prizePrice,
            description: _description,
            valid: true,
            emissor: msg.sender,
            buyer: msg.sender
        });

        optList.createOption(address(this));


    }


    function checkUpkeep(bytes calldata /* checkData */) external view override returns (bool upkeepNeeded, bytes memory /* performData */) {
        bool done;
        done = opc.valid;
        upkeepNeeded = done;        
        // We don't use the checkData in this example. The checkData is defined when the Upkeep was registered.
    }

    function performUpkeep(bytes calldata /* performData */) external override {
        //We highly recommend revalidating the upkeep in the performUpkeep function
        ethPrice = uint(priceEth.getLatestPrice());
        
        if(contador >= 10){
            executeOpc();
            contador = 0;
        }
        
        // We don't use the performData in this example. The performData is generated by the Keeper's call to your checkUpkeep function
    }


    function creatBuyRequest(uint _value) public {
        require(btgDOL(addr).balanceOf(msg.sender) > _value, "you dont have enought tokens");
        buyRequest memory newRequest = buyRequest({
            buyer: msg.sender,
            value: _value
        });

        buyersList.push(newRequest);
    }

    function aproveRequest(uint _index) public {
        require(msg.sender == opc.buyer, "You should be the option owner to call this function");
        address add = buyersList[_index].buyer;
        canBuy[add] = true;
    }
    
    function buyOpc(uint _price) public payable {
        require(btgDOL(addr).balanceOf(msg.sender) >= _price, "You dont't have enought tokens to buy this option");
        require(canBuy[msg.sender], "Your buy request was not approved");
        //require(_price >= opc.actualPrice, "The price you are ofering is lower than the Prize Price...");
        btgDOL(addr).transferFrom(msg.sender, opc.emissor, _price);
        opc.buyer = msg.sender;
    }

    function executeOpc() public payable returns(string memory _status){
        require(msg.sender == address(this), "Only the owner of the option can execute it");
        require(btgDOL(addr).balanceOf(opc.buyer) >= opc.strike, "You don't have enought tokens to make the transaction"); // se a btgUsd criar uma funcao de convesao automatica essa condicao pode ser ignorada
        if(ethPrice > opc.strike){
            btgDOL(addr).transferFrom(opc.buyer, opc.emissor, opc.strike);
            opc.valid = false;
            payable(msg.sender).transfer(address(this).balance);
            _status = "The option has been executed check your balance";
            return _status;
        }else {
            _status = "There's no sense in executing the option since it will return a loss";
            return _status;
        }
    }

}
